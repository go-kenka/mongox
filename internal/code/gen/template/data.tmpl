// Code generated by mongox, DO NOT EDIT.
package {{.Name | lower}}

import (
"context"
"errors"

"github.com/go-kenka/mongox/model/aggregates/watch"
"github.com/go-kenka/mongox/model/bulks"
"go.mongodb.org/mongo-driver/bson/primitive"
"go.mongodb.org/mongo-driver/mongo"
"go.mongodb.org/mongo-driver/mongo/options"
)

const (
    CollectionName    = "{{.Name | lower}}"
    {{- $paths := .PathList }}
    {{- $names := .FieldNames }}
    {{- range $i,$n :=$names}}
        {{ $n }} = "{{index $paths $i}}"
    {{- end -}}
)

{{- range $i,$o := .SubObject }}
type {{ $o.Name }}Data struct {
{{- range $j,$f := $o.Fields }}
    {{- if and (eq $f.FieldType 4) }}
        {{- if gt (len $f.EmbedData) 0 }}
            {{$f.Name | camelCase }}List []*{{$o.Name}}{{$f.Name | camelCase }}Data `bson:"{{$f.Name}}" {{$f.Tag}}`
        {{- else}}
            {{- if eq $f.ArrayType 0 }}
                {{$f.Name | camelCase }} []any `bson:"{{$f.Name}}" {{$f.Tag}}`
            {{- else}}
                {{$f.Name | camelCase }} []{{$f.ArrayType | goType}} `bson:"{{$f.Name}}" {{$f.Tag}}`
            {{- end}}
        {{- end}}
    {{- else if eq $f.FieldType 3 }}
        {{$f.Name | camelCase }} *{{$o.Name}}{{$f.Name | camelCase }}Data `bson:"{{$f.Name}}" {{$f.Tag}}`
    {{- else }}
        {{$f.Name | camelCase }} {{$f.FieldType | goType}} `bson:"{{$f.Name}}" {{$f.Tag}}`
    {{- end }}
{{- end }}
}
{{- end }}

func (d {{.Name }}Data) Document() any {
    return d
}
func (d {{.Name }}Data) Update() {}

type {{.Name }}Client struct {
    c  *mongo.Client
    db string
}

func New{{.Name}}Client(db *mongo.Client) *{{.Name}}Client {
    return &{{.Name}}Client{
        c: db,
    }
}

func (c *{{.Name}}Client) Database(database string) *{{.Name}}Client {
    c.db = database
    return c
}

func (c *{{.Name}}Client) collection() *mongo.Collection {
    if len(c.db) == 0 {
      panic(errors.New("db not set"))
    }

    return c.c.Database(c.db).Collection(CollectionName)
}

func (c *{{.Name}}Client) Query() *{{.Name}}Query {
	return NewUserQuery(c.collection())
}

func (c *{{.Name}}Client) Create() *{{.Name}}Create {
	return New{{.Name}}Create(c.collection())
}

func (c *{{.Name}}Client) UpdateMany() *{{.Name}}UpdateMany {
	return New{{.Name}}UpdateMany(c.collection())
}

func (c *{{.Name}}Client) UpdateOne() *{{.Name}}UpdateOne {
	return New{{.Name}}UpdateOne(c.collection())
}

func (c *{{.Name}}Client) UpdateOneID(id primitive.ObjectID) *{{.Name}}UpdateOneID {
	return New{{.Name}}UpdateOneID(id, c.collection())
}

func (c *{{.Name}}Client) ReplaceOne() *{{.Name}}ReplaceOne {
	return New{{.Name}}ReplaceOne(c.collection())
}

func (c *{{.Name}}Client) DeleteMany() *{{.Name}}DeleteMany {
	return New{{.Name}}DeleteMany(c.collection())
}

func (c *{{.Name}}Client) DeleteOne() *{{.Name}}DeleteOne {
	return New{{.Name}}DeleteOne(c.collection())
}

func (c *{{.Name}}Client) Aggregate() *{{.Name}}Aggregate {
	return New{{.Name}}Aggregate(c.collection())
}

func (c *{{.Name}}Client) Drop(ctx context.Context) error {
	return c.collection().Drop(ctx)
}

func (c *{{.Name}}Client) Watch(ctx context.Context, pipeline watch.WatchPipe, opts ...*options.ChangeStreamOptions) (*mongo.ChangeStream, error) {
	return c.collection().Watch(ctx, pipeline.Pipe(), opts...)
}

func (c *{{.Name}}Client) Indexes() mongo.IndexView {
	return c.collection().Indexes()
}

func (c *{{.Name}}Client) Clone(opts ...*options.CollectionOptions) (*mongo.Collection, error) {
	return c.collection().Clone(opts...)
}

func (c *{{.Name}}Client) Name() string {
	return c.collection().Name()
}

func (c *{{.Name}}Client) GetDatabase() *mongo.Database {
	return c.collection().Database()
}

func (c *{{.Name}}Client) BulkWrite(ctx context.Context, mds []bulks.BulkModel, opts ...*options.BulkWriteOptions) (*mongo.BulkWriteResult, error) {
	var models []mongo.WriteModel
	for _, stage := range mds {
		models = append(models, stage.WriteModel())
	}
	return c.collection().BulkWrite(ctx, models, opts...)
}
