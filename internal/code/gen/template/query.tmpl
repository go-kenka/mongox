// Code generated by mongox, DO NOT EDIT.
package {{.Name | lower}}

import (
	"context"

	"github.com/go-kenka/mongox/model/filters"
	"github.com/go-kenka/mongox/model/updates"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"
)

type {{.Name}}Query struct {
	cc        *mongo.Collection
	filter    bson.D
	update    any
	replace   *{{.Name}}Data
	fieldName string
}

func New{{.Name}}Query(cc *mongo.Collection) *{{.Name}}Query {
	return &{{.Name}}Query{cc: cc}
}

// SetFilter set filter
func (q *{{.Name}}Query) SetFilter(f filters.Filter) *{{.Name}}Query {
	q.filter = f.Document()
	return q
}

// SetUpdate set update doc, use when FindOneAndUpdate
func (q *{{.Name}}Query) SetUpdate(up updates.Update) *{{.Name}}Query {
	q.update = up.Document()
	return q
}

// SetReplace set replace doc, use when FindOneAndReplace
func (q *{{.Name}}Query) SetReplace(replace *{{.Name}}Data) *{{.Name}}Query {
	q.replace = replace
	return q
}

// SetFieldName set distinct fieldName, use when Distinct
func (q *{{.Name}}Query) SetFieldName(replace *{{.Name}}Data) *{{.Name}}Query {
	q.replace = replace
	return q
}

func (q *{{.Name}}Query) Find(ctx context.Context, opts ...*options.FindOptions) (result []*{{.Name}}Data, err error) {
	cur, err := q.cc.Find(ctx, q.filter, opts...)
	if err != nil {
		return nil, err
	}
	defer cur.Close(ctx)

	err = cur.All(ctx, &result)
	if err != nil {
		return nil, err
	}
	return
}

func (q *{{.Name}}Query) FindOne(ctx context.Context, opts ...*options.FindOneOptions) (result *{{.Name}}Data, err error) {
	err = q.cc.FindOne(ctx, q.filter, opts...).Decode(&result)
	if err != nil {
		return nil, err
	}
	return
}

func (q *{{.Name}}Query) FindOneAndReplace(ctx context.Context, opts ...*options.FindOneAndReplaceOptions) (result *{{.Name}}Data, err error) {
	err = q.cc.FindOneAndReplace(ctx, q.filter, q.replace, opts...).Decode(&result)
	if err != nil {
		return nil, err
	}
	return
}

func (q *{{.Name}}Query) FindOneAndUpdate(ctx context.Context, opts ...*options.FindOneAndUpdateOptions) (result *{{.Name}}Data, err error) {
	err = q.cc.FindOneAndUpdate(ctx, q.filter, q.update, opts...).Decode(&result)
	if err != nil {
		return nil, err
	}
	return
}

func (q *{{.Name}}Query) FindOneAndDelete(ctx context.Context, opts ...*options.FindOneAndDeleteOptions) (result *{{.Name}}Data, err error) {
	err = q.cc.FindOneAndDelete(ctx, q.filter, opts...).Decode(&result)
	if err != nil {
		return nil, err
	}
	return
}

func (q *{{.Name}}Query) CountDocuments(ctx context.Context, opts ...*options.CountOptions) (int64, error) {
	return q.cc.CountDocuments(ctx, q.filter, opts...)
}

func (q *{{.Name}}Query) EstimatedDocumentCount(ctx context.Context, opts ...*options.EstimatedDocumentCountOptions) (int64, error) {
	return q.cc.EstimatedDocumentCount(ctx, opts...)
}

func (q *{{.Name}}Query) Distinct(ctx context.Context, opts ...*options.DistinctOptions) ([]interface{}, error) {
	return q.cc.Distinct(ctx, q.fieldName, q.filter, opts...)
}
